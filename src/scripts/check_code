#!/usr/bin/perl

#
# netsniff-ng Project
# XXX: splint? or other tools
# Code analysis script... quite a hack, so you better 
# grab some coffee! ;)
#

#
# How to run?
#  * Install GCC::TranslationUnit as root with:
#    perl -MCPAN -e 'shell' and type 'install GCC::TranslationUnit'
#  * The other modules are mostly standard and should already be 
#    installed on your Linux box
#

use warnings;
use strict;

use Cwd;
use File::Find;
use File::Basename;
use GCC::TranslationUnit;

my @src_files;
my @err_list;
my @err_sym_list;

my %tu_files;
my @func_stack;

# v-- This config defines how the code should look like:
my %config = (
	max_global_vars                => 3,
	max_func_args                  => 4,
	max_func_lines                 => 100,
	max_file_lines                 => 700,
);

# v-- Generic functions
sub push_error
{
	my ($error, $condition) = @_;
	push(@err_list, $error) if($condition);
}

sub print_error_list
{
	my ($file, $fs) = ($_[0], substr($_[0], 0, length($_[0]) - 2));

	goto __skipped if($file !~ /\.c$/);
	foreach (@err_sym_list) {
		my @l = @{$_};
		if($l[0] =~ /$fs\.o$/) {
			push(@err_list, $l[1]);
		}
	}

__skipped:
	return if(scalar(@err_list) == 0);

	print "File $file:\n";
	foreach(@err_list) {
		print "  * $_\n";
	}
}

sub grep_source_files
{
	find sub {
		$_ = $File::Find::name;
		push(@src_files, $_) if(/\.(c|h)$/);
	}, (getcwd)."/../";
}

# v-- Make related stuff
sub invoke_make_build_normal { `make 2>&1 > /dev/zero`; }
sub invoke_make_build_tu     { `make ARGS=\"-fdump-translation-unit\" 2>&1 > /dev/zero`; }
sub invoke_make_clean        { `make clean 2>&1 > /dev/zero`; }

# v-- Object file related stuff
sub check_unused_symbols
{
	my ($obj, $type, $name);
	my @obj_list;
	my %symbols;

	invoke_make_build_normal();
	foreach(@src_files) {
		next if /\.h$/;
		$obj = $_; $obj =~ s/(.*)\.c$/$1\.o/;
		push(@obj_list, $obj) if -e $obj;
	}

	open(SRC, "nm @obj_list |") or die "Cannot read pipe from nm: $!\n";
	while(<SRC>) {
		if(/(.*):$/) {
			$obj = $1; next;
		}
		next if(length($_) < 12);
		$type = substr($_, 9, 1);
		$name = substr($_, 11);
		chomp($name);
		if($type =~ /U/) {
			$symbols{$name}->{ud} = $obj;
		} elsif($type !~ /[a-z]/) {
			$symbols{$name}->{d} = $obj;
		}
	}
	close(SRC);

	foreach(sort keys %symbols) {
		if(not defined($symbols{$_}->{ud})) {
			push(@err_sym_list, [$symbols{$_}->{d}, "Symbol \'$_\' either ".
			     "only locally used or never: Make it static or remove it!"]);
		}
	}
}

# v-- GCC TU related stuff
sub parse_translation_unit
{
	my $unit = shift;
	my ($file, $file_short);
	my $global_vars = 0;
	my $node = GCC::TranslationUnit::Parser->parsefile($unit)->root;

	$unit =~ m/(.*\.c)\..*\.tu$/;
	$file = $1;
	$file_short = basename($file);
	@err_list = ();

	while($node) {
		if($node->isa('GCC::Node::function_decl')) {
			if($node->{'source'} =~ m/$file_short/) {
				check_function($node);
			}
		}
		if($node->isa('GCC::Node::var_decl')) {
			if($node->{'source'} =~ m/$file_short/) {
				$global_vars++;
			}
		}
	} continue {
		$node = $node->chain;
	}

	push_error("File has too many global variables.", $config{max_global_vars} < $global_vars);
	return ($file, $file_short);
}

sub grep_translation_unit_files
{
	find sub {
		my $_ = $File::Find::name;
		if(m/^(.*)\.c.*\.tu$/) {
			$tu_files{$_} = $1;
		}
	}, getcwd;
}

sub check_function 
{
	my $node = shift;
	my ($name, @args);

	$name = $node->{'name'}->{'string'};
	@args = grep_function_args($node->{'type'}->{'prms'}, $name);
	push(@func_stack, $name);

	#push_error("Function $name has too many parameters.", $config{max_func_args} < scalar(@args));
	push_error("Function $name has too many parameters.", 1);
}

sub grep_function_args
{
	my ($prms, $name) = @_;
	my @args;

	while($prms && $prms->chain) {
		push(@args, $prms->{'name'}->{'string'});
		$prms = $prms->chain;
	}

	return @args;
}

# v-- Checking related routines
sub check_copyright { return ($_[0] =~ m/copyright/i); }

sub check_file_generic
{
	my $file = shift;
	my (@source, $lines);
	
	# Check lines
	{
		open(SRC, "< $file") || die "E: Cannot open file $file: $!\n";
		$lines = scalar((@source = <SRC>));
		close(SRC);
		
		push_error("File has too many code lines.", $config{max_file_lines} < $lines);
	}
	
	# Check generic statements, some recommendations are from checkpatch.pl (see Kernel)
	{
		my $got_copyright = 0;
		my $got_license = 0;
		
		for(my $i = 0; $i < scalar(@source); ++$i) {
			if($got_copyright == 0 && 
			   $source[$i] =~ m/copyright/i) {
				$got_copyright++;
			}
			
			if($got_license == 0 && 
			   $source[$i] =~ m/gpl|license|gnu\sgeneral\spublic\slicense/i) {
				$got_license++;
			}
			
			if($source[$i] =~ /\*\s*\)\s*[xczm]alloc\b/) {
				push_error("Line ".($i + 1).": Unnecessary cast may hide bugs (see http://c-faq.com/malloc/mallocnocast.html).", 1);
			}
#			if($source[$i] =~ /\s*str[^n]\w+\b/) {
#				push_error("Line ".($i + 1).": String functions without length restriction should never be used.", 1);
#			}
		}
		
		push_error("File does not start with header comment.", ($source[0] =~ m/\/\*.*/i) == 0);
		push_error("File has no copyright statement.", $got_copyright == 0);
		push_error("File has no licence statement.", $got_license == 0);
	}
}

# v-- Main routine
sub main
{
	my $conflicts = 0;

	grep_source_files();

	# Special or global checks ...
	check_unused_symbols();

	invoke_make_build_tu();
	grep_translation_unit_files();

	foreach(@src_files) {
		parse_translation_unit($tu_files{$_}) if defined($tu_files{$_});

		# Special or global checks ...
		check_file_generic($_);

		print_error_list(basename($_));
		$conflicts += scalar(@err_list);
		@err_list = ();
	}

	invoke_make_clean();
	print "Done with $conflicts conflicts.\n";
}

main();
exit 0;
